# Референция (Reference)

## Дефиниция

**Референцията** е **алтернативно име (псевдоним/alias) за съществуваща променлива**.

### Основни характеристики:

- Декларира се чрез оператора `&` след типа.
- Трябва да бъде **инициализирана веднага** при декларация.
- След инициализация **не може да се пренасочи** към друга променлива.
- Типът на референцията и променливата **трябва да съвпадат**.
- **Не копира данни** - директен достъп до оригиналната променлива.
- **Предотвратява копирането** на големи структури от данни.
- **Винаги валидна** - не може да бъде null (за разлика от указателите).

### Референция като параметър на функция

**Pass by value (по копие) vs Pass by reference (по референция):**

```c++
void example1(int a) {
    a += 5; //copy | no modification
}

void example2(int& a) {
    a += 5; //by reference | modified
}

int main()
{
    int x = 5;
    
    std::cout << "Original: " << x << std::endl;     // 5
    
    example1(x); // Подава се копие на x
    std::cout << "After example1: " << x << std::endl; // 5 (БЕЗ промяна!)
    
    example2(x); // Подава се референция към x
    std::cout << "After example2: " << x << std::endl; // 10 (С промяна!)
    
    return 0;
}
```

**Какво се случва:**
- В `example1()` - създава се **копие** на `x`, промените засягат само копието
- В `example2()` - `a` е **референция** към `x`, промените засягат директно `x`

### Пример: Разлика между копие и референция

```c++
// Пример: БЕЗ референция (създават се копия)
unsigned int FamilyMoney = 100;
unsigned int MomMoney = FamilyMoney;    // Копие на стойността
unsigned int FatherMoney = FamilyMoney; // Друго копие

MomMoney -= 30; // Променя само MomMoney

std::cout << "Mom: " << MomMoney << ", Father: " << FatherMoney << std::endl;
// Изход: Mom: 70, Father: 100 (FatherMoney НЕ е засегнато)

// Пример: С референция (споделен достъп)
unsigned int FamilyMoney = 100;
unsigned int &MomMoney = FamilyMoney;    // Референция към FamilyMoney
unsigned int &FatherMoney = FamilyMoney; // Друга референция към същото

MomMoney -= 30; // Променя FamilyMoney директно

std::cout << "Mom: " << MomMoney << ", Father: " << FatherMoney << std::endl;
// Изход: Mom: 70, Father: 70 (и двете са референции към FamilyMoney)

std::cout << "Family: " << FamilyMoney << std::endl; // 70
```

**Обяснение:**
- Без референция: всяка променлива има **своя копие** на данните
- С референция: всички променливи сочат към **едни и същи данни** в паметта

### Класически пример: Функция swap

- swap (по копие):
```c++
void swap(double a, double b) // Параметри по копие
{
    double temp = a;
    a = b;
    b = temp;
    // Разменят се САМО локалните копия!
}

int main()
{
    double x = 3.5, y = 7.2;
    std::cout << "Before: x=" << x << ", y=" << y << std::endl; // 3.5, 7.2
    
    swap(x, y); // Нищо няма да се случи!
    
    std::cout << "After: x=" << x << ", y=" << y << std::endl;  // 3.5, 7.2
    // x и y НЕ СА разменени, защото функцията работи с копия!
    return 0;
}
```

- swap (по референция):
```c++
void swap(double& a, double& b) // Параметри по референция
{
    double temp = a;
    a = b;
    b = temp;
    // Разменят се оригиналните променливи!
}

int main()
{
    double x = 3.5, y = 7.2;
    std::cout << "Before: x=" << x << ", y=" << y << std::endl; // 3.5, 7.2
    
    swap(x, y); // Работи!
    
    std::cout << "After: x=" << x << ", y=" << y << std::endl;  // 7.2, 3.5
    // x и y СА разменени успешно!
    return 0;
}
```

### Функция връщаща референция
- когато връщате референция, Вие не връщате стойността на променливата, а цялата променлива.
- трябва да сте сигурни, че променливата, чиято референция връщате, **съществува и следприключването на функцията**, тоест **не връщате локално създаден обект**.

```c++
int& errorProne() {
    int a = 5;
    return a;
}
//Недефинирано поведение, което компилаторът на Visual Studio, любезно заличава, но реално това е проблем и не всички компилатори го позволяват
```

## Указател

- Променлива, която пази адрес(memory address) като стойност.
- Променливата на указател сочи към типа данни, от същия тип, която е и тя, и се създава чрез оператор *.
- Адресът на променливата, с която работите, се присвоява на указателя. 

```c++
int number = 5;
int* ptr = &number; // ptr съхранява адреса на number

std::cout << "Value of number: " << number << std::endl;        // 5
std::cout << "Address of number: " << &number << std::endl;     // 0x... (адрес)
std::cout << "Value of ptr: " << ptr << std::endl;              // 0x... (същият адрес)
std::cout << "Value at address ptr: " << *ptr << std::endl;     // 5 (дереференция)

*ptr = 10; // Променя number чрез указателя
std::cout << "New value of number: " << number << std::endl;    // 10
```

### Работа с указатели - Стъпка по стъпка

```c++
    //create pointer and set it to address of variable
    bool* engineer = nullptr; 
    bool plane1 = true;
    engineer = &plane1;

    //create another pointer and set it to point to the same address as the first pointer
    bool* gremlin = engineer;

    //decrement the value 
    (*gremlin)--;

    //set the value to true
    *engineer = true;

    //set value
    bool plane2 = *engineer;
    *gremlin = false;

    //set pointer to plane2's address
    gremlin = &plane2;

    //set value
    *engineer = 1;

    //set gremlin's value to opposite of engineer's value
    *gremlin = !(*engineer);
```

### Nullptr
- pointer literal(пойнтеров литерал).
- Не може да се вземе адреса му с &.
- nullptr сочи към адрес 0x00000000.

```c++
// function with integer argument
void fun(int N)  { 
    std::cout << "fun(int)\n";
}

// Overloaded function with char pointer argument
void fun(char* s) {
    std::cout << "fun(char*)\n";
}

int main() {
    fun(NULL);
}
//call of overloaded 'fun(NULL)' is ambiguous
```

### Указатели към константи/Константни указатели
Указателите към константа – НЕ може да се променя стойността на променливата, към която сочат.
- const int* - указател към константа
- int const* - указател към константа

![Pointer to const & const pointer](images/example1.png)

Константните указатели са като референциите, но са указатели.
Може да се променя стойността на променливата, но НЕ може да се променя да сочи към друга променлива.
- int* const – константен указател

![Const pointer to const](images/example2.png)

### Spiral Rule - Bjarne Stroustrup
Правилото гласи, започнете от името на променливата и се придвижваме по посока на часовниковата стрелка до следващия указател или тип.

![Spiral rule](images/spiral-rule.jfif)

```c++
const int * const == int const * const – константен пойнтър към константа

( int *) * const – константен пойнтър към пойнтър от тип int

( (int ) * const )* - пойнтър към константен пойнтър към int

( ( int const ) *) * - двоен пойнтър към константа от тип int

( ( int ) * const ) * const – константен пойнтър към константен пойнтър към int

( ( const int ) * const ) * const – константен пойнтър към константен пойнтър към константа от тип int
```

## Допълнителна информация

### x32/x86 vs x64

Тези термини (често записвани като 32-bit и 64-bit) описват размера на думата на процесора на компютъра - колко данни може да обработи или адресира наведнъж.
- **32-битови системи** използват 32-битови адреси на паметта → максимална адресируема памет = 2³² байта = 4 GB
- **64-битови системи** използват 64-битови адреси на паметта → теоретичен максимум = 2⁶⁴ байта (≈ 16 ексабайта!) (1 ексабайт = 1 милиард GB) → практически, операционните системи го ограничават (например Windows позволява до няколко терабайта)
Така че 64-битов процесор/ОС може да работи с много повече RAM.

**В: Заема ли референцията памет? Каква е разликата между референция и константен указател?** <br />
О: Референцията обикновено не заема допълнителна памет в повечето случаи - тя е просто псевдоним (alias) за съществуваща променлива. Компилаторът я третира като директен достъп до оригиналната променлива. Въпреки това, в някои случаи (особено когато се връща референция от функция или се съхранява в клас), компилаторът може да я имплементира вътрешно като указател.

Разлики между референция и константен указател (`int* const`):
- Референцията **трябва** да се инициализира при декларация и не може да се пренасочи към друга променлива.
- Константният указател също не може да се пренасочи, но **може** да се декларира без инициализация (макар и да не е добра практика).
- Референцията използва по-проста синтаксис (не се нуждае от `*` за дереференция).
- Константният указател може да бъде `nullptr`, докато референцията винаги трябва да сочи към валиден обект.
- Референцията е по-безопасна, тъй като не може да бъде null.

**В: Защо указателите са 4 байта или 8 байта в зависимост от архитектурата?** <br />
О: Указателите съхраняват **адреси на паметта**, следователно размерът им зависи от адресното пространство на системата:
- На **32-битова (x86) архитектура**: указателите са **4 байта** (32 бита), защото адресите са 32-битови → може да адресира до 2³² = 4 GB памет
- На **64-битова (x64) архитектура**: указателите са **8 байта** (64 бита), защото адресите са 64-битови → може да адресира много повече памет (теоретично до 2⁶⁴ байта)

Това означава, че на 64-битова система всички указатели (независимо към какъв тип сочат - `int*`, `char*`, `double*`) заемат 8 байта, докато на 32-битова система заемат 4 байта.

## Задачи

### Референции

**1.**  Да се напише функция swap, която приема 2 числа и разменя стойностите им. <br />
  Вход: 5 7  | Изход: 7 5 <br />

**2.** Да се напишат функции <br />
- *toUpper*, която приема буква и я превръща в съответстващата й голяма; <br />
- *toLower*, която приема буква и я превръща в съответстващата й малка. <br />

**3.** Да се напише функция *sort3(int& min, int& mid, int& max)*, която приема 3 числа и ги сортира във възходящ ред.

  Вход: 4 5 3  | Изход: 3 4 5 <br />

**4.** Да се напише фунция, която приема 2 числа - числител и знаменател на обикновена дроб, и съкращава дробта. Напишете програма, която извежда сбора на 2 такива дробни числа.<br />

### Указатели

**1.** Дадени са два указателя към цели числа. Напишете функция, която разменя това, към което сочат указателите —
т.е. след извикването ѝ първият указател трябва да сочи към променливата, към която е сочил вторият, и обратно.

**2.** Напишете функция, която приема две числа и връща указател към променливата с по-голяма стойност.
