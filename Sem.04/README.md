## Функции.

**Дефиниция:** <br />
В контекста на програмирането, функция се нарича **именувана група от инструкции, които изпълняват дадена функционалност**.

```c++
<сигнатура> <идентификатор> (<параметър>, <параметър> ...)
{
      <тяло>
}
```

**Семантика:** <br />
- <сигнатура> - <тип_резултат> | void
- <идентификатор> - име на функцията
- <параметър> - всеки параметър се състои от <тип> и <индентификатор>

**Важно:** <br />
- void = празен тип, не връща резултат.
- Ако функция със сигнатура различна от void не връща стойност се получава грешка при компилация.
- Ако параметър е примитивен тип данна или някакъв обект, то се създава нов обект в scope-а на функцията.
- Извикването на функция всъщност е операция с много висок приоритет

```c++
#include<iostream>

void helloWorld()
{
    std::cout << "Hello World!" <<std::endl;
}

int main() 
{
    helloWorld();
    return 0;
}
```

Оператор **return**:
-  Прекратява изпълнението на функцията.
-  Замества извикването и с резултата (връща резултата).
 
Операторът може да се използва и при функции, които не връщат нищо (void функции), тогава return единствено прекратява функцията.

```c++
int max(int n, int k)
{
    return n > k ? n : k;
}
```

### Параметри по копие
```c++
#include <iostream>

void f(int n)
{
    n++;
}

int main()
{
    int n = 4;
    f(n);
    std::cout << n << endl; //4
    
    return 0;
}
```
Важно: Функциите, написани по този начин, приемат своите параметри **по копие**.

### Параметри по референция
Алтернативно име на съществуваща променлива. Променливата може да бъде декларирана като референция чрез **&**. <br />
Ако функция получи рефенция към променлива, тя може да променя(modify) стойността на променливата(директно). <br />
По този начин предотвратява копирането на данни. <br />

```c++
void swap(double &a, double &b)
{
    double temp = a;
    a = b;
    b = temp;
}
```

### Function overloading
Една функция може да има безброй много overloads. <br />
При извикване на функцията, компилаторът се грижи да намери правилният overload на функцията. <br />
Компилаторът може да направи преобразуване на данните ако се налага. <br />
Ако не намери подходящ се получава грешка при компилиране. <br />
Ако намери повече от 1 подходящ се получава грешка за двусмислие. <br />

```c++
    void cout(char a) { std::cout << a; } //1

    void cout(int a) { std::cout << a; } //2

    void cout(char a, int b) { std::cout << a << '-' << b; } //3

    void cout(double a, char b) { std::cout << b << '-' << a; } //4

    void cout(bool a) { std::cout << a; } //5

    void cout(char a, bool b, int c) { std::cout << a <<b << c; } //6

    void cout(const int a) { std::cout << a; } //7

    void cout(char a, unsigned b) { std::cout << a << '-' <<b; } //8

    char cout(char a) { return a; } //9
```

```c++
    void cout(char a) { std::cout << a; } //двусмислие с 9

    void cout(int a) { std::cout << a; } // двусмислие със 7

    void cout(char a, int b) { std::cout << a << '-' << b; } //двусмислие с 8

    /*-------------------------------------------------------*/
    void cout(double a, char b) { std::cout << b << '-' << a; }

    void cout(bool a) { std::cout << a; }

    void cout(char a, bool b, int c) { std::cout << a << b << c; }
    /*-------------------------------------------------------*/

    void cout(const int a) { std::cout << a; } // двусмислие с 2

    void cout(char a, unsigned b) { std::cout << a << '-' << b; } // двусмислие с 3

    char cout(char a) { return a; } // двусмислие с 1
```

**Важно!** <br />
За компилатора има значение подредбата на параметрите. Ако спрямо дадената подредба няма отговаряща функция се получава грешка при компилация

### Параметри по подразбиране
Възможно е да имате програма, в която 90% от случаите подавате eдин и същ параметър на дадено място. <br />
C++ позволява да имате стойност по подразбиране за 1 или повече параметри, които не се налага да уточнявате при извикване на функцията. <br />

```c++
#include <iostream>

void print(int a, int b = 5)
{
    std::cout << a << " " << b;
}

int main()
{
    print(4); // 4 5
    print(3, 6); // 3 6
    
    return 0;
}
```

**Параметрите по подразбиране трябва винаги да са в края!!!**
```c++
#include <iostream>

void print(int a, int b = 5, char c = 't')
{
    std::cout << a << " " << b << " " << c;
}

int main()
{
    print(4); // 4 5 t
    print(3,6); // 3 6 t
    print(3, '0'); // 3 48 t
    
    return 0;
}

//‘0’ има стойност 48 в ASCII => компилаторът го разглежда като int със стойност 48
```

**Параметрите по подразбиране винаги са в последователността, в която са дефинирани, не могат да се прескачат**

### Function Declaration vs Definition
Declaration – казва на компилатора, че така функция съществува. <br />
Definition – казва на компилатора, какво всъщност прави тази функция(нейната функционалност). <br />
Една функция **може да бъде декларирана**, но да **не бъде дефинирана**. Получаваме компилационна грешка, ако тази функция бъде извикана. <br />

```c++
#include <iostream>

void helloWorld(); //Declaration

int main() 
{
    helloWorld();
    
    return 0;
}

void helloWorld() //Definition
{
    std::cout << "Hello World!\n";
}
```

## Задачи
1. Напишете функция, която приема неотрицателно число n и връща числото обърнато. <br />

      Вход: 288, Изход: 882

2. Напишете функция, която приема неотрицателно число и връща дали числото е палиндром. <br />

      Вход: 2882 Изход: true

3. Напишете функция, която приема неотрицателно число и връща дали цифрите му са сортирани (във възходящ или в низходящ ред). <br />

      Вход: 122239, Изход: true
