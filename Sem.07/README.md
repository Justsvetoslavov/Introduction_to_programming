# Символен низ

## Определение
- Символен низ наричаме **последователност от символи**.
- Последователност от 0 символи наричаме **празен низ**.
- Представяне в C++ - масив от символи (char), който завършва със специалния символ **'\0'**(терминираща нула).

```c++
    char word[] = { 'H', 'e', 'l', 'l', 'o', '\0' };
    char word[5] = { 'H', 'e', 'l', 'l', 'o' }; //обикновен масив от символи
    char word[6] = { 'H', 'e', 'l', 'l', 'o' }; // '\0' се добавя автоматично
    char word[100] = "Hello";
    char word[5] = "Hello"; // невалидно, понеже " " включват в себе си '\0'
    char word[6] = "Hello"; // валидно
```

## Tерминираща нула - \0
- Първият символ в ASCII таблицата, с код 0 – т.е **char(0)**.
- Брои се като елемент и **влияе** на размера на масив.
- Използва се като **прекъсвач (терминатор)** от много функции за символни низове, за да се определя края на низа.

```c++
    //Може да се сложи в средата на масив от символи
    char a []= {'H', 'e', 'l', 'l','\0', 'o'}; //символният низ е "Hell"
```

## Инициализация на символни низове
- Чрез инициализатор
```c++
    //Чрез инициализатор
    char text[16] = {'C','+','+', '\0'};
    char sameText[] = {'C','+','+', '\0'};

    //Чрез литерал
    char sameTextAgain[] = "C++";
    char sameTextYetAgain[16] = "C++";
```
- Чрез литерал
```c++
char sameTextAgain[] = "C++";       // автоматично добавя '\0'
char sameTextYetAgain[16] = "C++";  // останалите символи са '\0'
```
Пояснение:
- В информатиката под **литерал** се разбира константна стойност на променлива, зададена в сорс кода на дадена компютърна програма.
- Tl;dr - Литерал e константна стойност, зададена директно в кода.

## Въвеждане на символни низове  
- `cin`/`cin >>` - чете само до първия интервал:
```c++
char name[100];
cin >> name;
```
- cin.getline() - чете цял ред (включително интервали):
```c++
char text[100];
cin.getline(text, 100);
```

## Обхождане на символен низ
- Пример с масив:
```c++
for (int i = 0; text[i] != '\0'; i++) {
    cout << text[i];
}
```
- Пример с указател:
```c++
char* p = text;
while (*p != '\0') {
    cout << *p;
    p++;
}
```

## Защо не можем да присвояваме масиви директно
Нека разгледаме следния пример:
```c++
char text[10];
text = "Hello"
```
Когато пишеш:
```c++
char text[10];
```
се случва следното:
- text не е променлива, а фиксиран блок памет, състоящ се от 10 елемента char.
- името text е константен указател към първия елемент на масива.
- Масивът не може да бъде преместван, променян като цял обект или „присвояван“.

Затова `text = "Hello";` е невалидно, защото се опитваме да "преприсвоим" адреса на масива, а text не може да промени адреса си, т.е. не може да получава нова стойност.


## Разлика между C-style string и std::string

### C-style strings (char[])
- Ниско ниво - директна работа с паметта
- Ръчно управление на памет - програмистът е отговорен за размера и алокацията
- Терминираща нула - задължително използване на '\0' за маркиране края на низа
- Фиксиран размер - размерът се определя при декларация и не може да се променя
- Липса на вградени функции - нужни са външни функции (strlen, strcpy, strcmp и др.)
- По-бърз достъп - директен достъп до паметта без допълнителни абстракции
- Подходящ за обучение - помага да се разбере как работят низовете на ниско ниво

```c++
char str1[50] = "Hello";
char str2[50];
strcpy(str2, str1);  // трябва да използваме функция за копиране
```

### std::string
- Високо ниво - абстракция над C-style strings
- Автоматично управление на памет - динамично преоразмеряване при нужда
- Без терминираща нула - вътрешно се управлява, но не е задължително да се мисли за нея
- Динамичен размер - може да расте и намалява според нуждите
- Богат набор от методи - length(), substr(), find(), append(), + оператор и др.
- По-безопасен - предпазва от buffer overflow и други грешки
- Част от STL - интегриран с останалите контейнери и алгоритми

```c++
#include <string>

std::string str1 = "Hello";
std::string str2 = str1;  // лесно копиране
str1 += " World";         // лесна конкатенация
```

### Кога да използваме кое?
- C-style strings: системно програмиране, legacy код, работа с C библиотеки, образователни цели
- std::string: модерен C++ код, когато се нуждаем от динамични операции, за по-безопасен и четим код

Пояснение: В курса по Увод в програмирането, няма да може да използваме `std::string`, освен ако експлицитно не е позволено.

## Задачи:
1. Напишете имплементация на **strlen** - *връща колко символа има от началото до ‘\0’*

2. Напишете имплементация на **strcmp** - *сравнява 2 символни низа (> , = , <)*

3. Напишете имплементация на **strcat** - *конкатенация*

4. Напишете имплементация на **strcpy** - *копира source в destination*

5. Напишете имплементация на **аtoi** - *преобразуване на стринг в число*

6. Напишете имплементация на **searchInText** - *търсене в текст*.

7. Напишете импелментация на **getCharoOccurrencesCount** - *брой срещания на кнокретен символ в текст*.