# Архитектура и управление на паметта

## Въведение: Хардуер и Архитектура
(Записки от теми по КАРХ за държавен изпит - необходима база за разбиране на паметта)
- [Компютърни архитектури. Формати на данните. Вътрешна структура на централен процесор - блокове и конвейерна обработка, инструкции.](https://github.com/Justsvetoslavov/FMI-State-Exam-Prep/blob/master/03-Theory/05.md)
- [Структура и йерархия на паметта. Сегментна и странична преадресация. Система за прекъсване - приоритети и обслужване.](https://github.com/Justsvetoslavov/FMI-State-Exam-Prep/blob/master/03-Theory/06.md)

## Модел на изпълнение (Workflow): От Код до Памет

### Работен процес (The Workflow)
```
+----------------+     +--------------+     +-------------------+     +------------------+
|  Source Code   | --> |   Compiler   | --> | Object File (.obj)| --> |     Linker       |
|  (main.cpp)    |     | (g++, MSVC)  |     | (.o / .obj)       |     |                  |
+----------------+     +--------------+     +-------------------+     +------------------+
                                                                              |
                                                                              v
                                                                      +------------------+
                                                                      | Executable (.exe)|
                                                                      |  Machine Code    |
                                                                      +------------------+
                                                                              |
                                                                              v
                                                                      +------------------+
                                                                      |   RAM Memory     |
                                                                      | (Running Process)|
                                                                      +------------------+
```

### Обяснение
- Source Code
  - Вие пишете четим текстов код (напр. main.cpp), който човек може да разбере, но компютърът не може да изпълнява директно.
- Compilation
  - Компилаторът превежда сорс кода в object файл (`.obj` / `.o`), който съдържа машинен код, но все още не е завършена програма (има неразрешени връзки към други функции и библиотеки).
- Linking
  - Linker-ът обединява един или повече object файлове и нужните библиотеки и създава изпълним файл (`.exe`), който вече може да бъде стартиран.
- Loading
  - Когато натиснете Run, операционната система взема изпълнимия файл от диска и го зарежда в оперативната памет (RAM), създавайки процес, който започва изпълнение от `main()`.

> Важно: Под „памет“ тук разбираме RAM, където програмата съществува и работи активно, а не твърдия диск (storage), където файловете се съхраняват постоянно.

> Забележка: В уводни примери стъпките Compilation и Linking често се обединяват концептуално,
но в реалността те са отделни етапи.

## Проблемът с паметта и Решението (Виртуална памет)
Ако всяка програма пишеше директно във физическата RAM памет, щяхме да имаме хаос (програмите щяха да се презаписват една друга). Затова използваме Виртуална памет.

### Virtual vs. Real Memory
```
ВИРТУАЛНА ПАМЕТ (Илюзията)                      РЕАЛНА ПАМЕТ (Физическа RAM)
(Това вижда вашата програма)                    (Това притежава компютърът)

+----------------------------------+            +-----------------------------+
| Адрес 0x00000000                 |            |  Физически Адрес 0xAF30     |
| ................................ |            |  .........................  |
| ................................ |            |  .........................  |
| (Програмата "вижда" виртуално    |            |  (Ограничен размер, напр.   |
|  адресно пространство с размер   |            |   16GB споделени между      |
|  2^N адреса: от 0 до 2^N - 1)    |            |   всички програми)          |
| ................................ |            +-----------------------------+
| Адрес 0xFFFFFFFF (при 32-bit)    |
+----------------------------------+
```
- Абстракция на процеса: Всяка програма е изолирана в "Процес".
  - Всеки процес получава достъп до виртуално адресно пространство с обхват от $0$ до $2^n - 1$, където:
    - $n = 32$ за 32-битови системи (до ~4GB адресно пространство)
    - $n = 64$ за 64-битови системи (теоретично до ~16 ексабайта)
  - Процесите са напълно изолирани един от друг – не могат да достъпват паметта на други процеси.
- "Илюзия": Програмата си мисли, че има непрекъснат блок памет само за себе си (от $0$ до $2^{64}-1$ при 64-битови системи).
- Реалност: Физически данните са разпръснати из RAM плочките, но програмата не го знае.

## Хардуерният "Полицай": MMU (Memory Management Unit)
Кой поддържа тази "илюзия"? Хардуерен чип, наречен MMU, който стои между процесора и паметта.

### Ролята на MMU
```
   +-------+  Виртуален Адрес      +-------+    Физически Адрес      +-------+
   |  CPU  |  (напр. 0x00F3A) ---> |  MMU  |    (напр. 0x8B100) ---> |  RAM  |
   +-------+                       +-------+                         +-------+
                                       |
                                       | (Ако паметта е пълна -> Swap)
                                       v
                                +------------+
                                | Hard Drive |
                                +------------+
```
Функции на MMU:
- Транслация: Превежда виртуалния адрес (който pointer-ът сочи) към реален физически адрес.
  - MMU използва специални таблици (Page Tables), за да направи това мапване бързо и ефективно.
- Paging (Странициране): Не зарежда цялата програма в RAM. Зарежда само активните части ("страници").
  - CPU и MMU не зареждат изпълнимия файл изцяло в RAM.
  - Зареждат се само частите, които в момента се изпълняват или са необходими.
  - Това прави ефективно използване на реалната физическа памет (RAM).
- Swapping: Ако RAM паметта се препълни, MMU и ОС преместват неизползваните данни на твърдия диск (това е бавно, но спасява системата от краш).
  - Неизползваните страници се "изхвърлят" от RAM и се съхраняват на твърдия диск/SSD (swap space).
  - При нужда те се зареждат обратно в RAM (page fault).

## Организация на паметта (Memory Layout)

Когато една C++ програма се стартира, операционната система (ОС) ѝ заделя виртуално адресно пространство. Това пространство е организирано в специфични сегменти, всеки от които има различна роля, поведение и начин на управление.

### Визуална диаграма на паметта

Адресите в паметта обикновено се визуализират от **високи** (High Addresses) към **ниски** (Low Addresses).

```text
      ВИСОКИ АДРЕСИ (High Memory Addresses)
      (напр. 0xFFFFFFFF при 32-bit системи)
+--------------------------------------------------+
|               KERNEL SPACE (ОС)                  | <- Забранена зона за вашата програма
+--------------------------------------------------+
|                                                  |
|                  STACK (Стек)                    | <- Локални променливи (int a = 5;)
|             (Расте НАДОЛУ / Downwards)           |    Автоматично управление (LIFO)
|                      |                           |
|                      v                           |
|                                                  |
|               (Свободна памет)                   | <- Дупка между Stack и Heap
|                                                  |
|                      ^                           |
|                      |                           |
|                  HEAP (Хийп)                     | <- Динамична памет (new int;)
|              (Расте НАГОРЕ / Upwards)            |    Ръчно управление
|                                                  |
+--------------------------------------------------+
|           DATA / BSS (Global/Static)             | <- Глобални променливи
+--------------------------------------------------+
|                  TEXT (Code)                     | <- Бинарният код на функциите
|                  (Read-Only)                     |    (main, printf, etc.)
+--------------------------------------------------+
        НИСКИ АДРЕСИ (Low Memory Addresses)
              (напр. 0x00000000)
```

### Детайлно описание на сегментите

#### Text Segment (Code Segment)
Това е най-долният сегмент (на най-ниските адреси). Тук се намира самият изпълним код на програмата – компилираните машинни инструкции (бинарният код на функциите main(), printf() и т.н.).

Характеристики:
- Read-Only: Обикновено е само за четене, за да се предотврати случайното променяне на инструкциите по време на работа (което би довело до краш).
- Fixed Size: Размерът му се определя по време на компилация и не се променя.

Предимства:
- Може да бъде споделян между няколко процеса, ако те изпълняват една и съща програма (пести памет).
- Защитен е от пренаписване.

#### Data Segment (Static/Global Memory)
Този сегмент съхранява глобалните и статичните променливи, които живеят през целия живот на програмата. Често се разглежда като две подчасти:
- Initialized Data
- BSS (Uninitialized Data)
  - ОС автоматично ги занулява при старта.

Характеристики: Паметта се заделя при стартиране на програмата и се освобождава чак при нейното приключване.  
Предимства: Лесен достъп от всяка точка на програмата (глобален обхват).  
Недостатъци: Заемат памет постоянно, дори да не се използват в момента.  

#### Heap (Динамична памет)
Това е зоната за динамично заделяне на памет (Dynamic Memory Allocation).  
Тук се случват операциите с `new/delete` (в C++) или `malloc/free` (в C).

Характеристики:
- Расте нагоре: Към по-високи адреси (в повечето архитектури).
- Ръчно управление: Програмистът е длъжен да задели и освободи паметта.
- Живот: Обектите живеят, докато не бъдат изрично освободени/изтрити.
- Механизъм на алокация (`new`/`malloc`):
  - Извиква се OS kernel (операционната система).
  - В C++: `new` извиква `malloc`, който на свой ред извиква системни извиквания като `mmap` (memory map) или `sbrk` (set program break).
  - OS-ът търси свободен блок памет с подходящ размер в heap-а.
  - Когато намери подходящ блок, маркира го като зает (обикновено чрез флагове/metadata - set bit to 1).
  - Връща адреса на началото на този блок към програмата.
- Механизъм на деалокация (`delete`/`free`):
  - **Важно**: `delete` НЕ изтрива реално данните от паметта!
  - Просто маркира блока като свободен (set bit to 0), като променя metadata флага.
  - Самите данни остават непроменени в паметта, докато не бъдат презаписани от нова алокация.
  - **Security риск**: Чувствителни данни (пароли, криптографски ключове) могат да останат достъпни в паметта след `delete`.

Предимства:
- Гъвкавост: Позволява заделяне на масиви и обекти с размер, който не е известен преди стартирането на програмата (Runtime).
- Голям обем: Ограничен е главно от виртуалната памет и RAM-а, може да съхранява много големи структури.
- Персистентност: Данните оцеляват и след излизане от функцията, която ги е създала.

Недостатъци:
- Бавно действие: 
  - Заделянето изисква извикване на OS kernel (скъпа операция - context switch между user space и kernel space).
  - OS търси свободен блок с подходящ размер, което отнема време.
  - Управлението на metadata (флагове, размери на блокове) добавя overhead.
- Фрагментация: Честото заделяне и триене може да "надупчи" паметта.
- Memory Leaks: Риск от изтичане на памет, ако забравим delete.
- Dereferencing overhead: Достъпът е малко по-бавен (чрез pointer).
- Сигурност: Данните не се изтриват реално при `delete`, само се маркират като свободни. Чувствителна информация може да остане в паметта.

#### Stack (Стекова памет)
Това е работната памет за изпълнение на функции. Тук се съхраняват локалните променливи, параметрите на функциите и адресите за връщане (return addresses).

Характеристики:
- Заделяне (Allocation): Стекът се заделя предварително (preallocated) при стартирането на нишка (thread). Всяка нишка получава собствен стек с фиксиран размер.
- Расте надолу: Към по-ниски адреси. Когато извикате функция, тя "натиска" (push) нови данни надолу.
- LIFO/FILO (Last-In, First-Out / First-In, Last-Out): Последните влезли данни се освобождават първи.
- Освобождаване (Deallocation): Извършва се чрез просто преместване на Stack Pointer (SP) нагоре. Няма реално "изтриване" – просто указателят се премества и старата памет се счита за невалидна.
- Автоматично управление: Паметта се освобождава сама, когато блокът (scope) приключи (}).
- Stack Pointer (SP): CPU съхранява указател към върха на стека в специален, посветен регистър.
  - На x86-64 архитектура този регистър се нарича `%rsp` (Stack Pointer Register).
  - На ARM архитектура се използва `SP` регистър.
  - Този регистър следи текущия адрес на върха на стека, позволявайки бързи функционални извиквания, управление на локални променливи и съхранение на адреси за връщане.
  - Въпреки че регистърът е в CPU, самите данни на стека се съхраняват в RAM паметта.

Предимства:
- Изключително бърза: 
  - Заделянето и освобождаването са тривиални операции – просто инкремент/декремент на Stack Pointer регистъра.
  - Изпълнява се с една CPU инструкция (напр. `push`/`pop`, `sub rsp, N` / `add rsp, N`).
  - Не изисква сложни алгоритми за търсене на свободна памет (за разлика от Heap).
- Cache-friendly: 
  - Данните са подредени плътно една до друга в последователни адреси.
  - Stack данните обикновено се кешират в CPU кеш паметта (L1/L2/L3 cache), което прави достъпа изключително бърз.
- Без Memory Leaks: Няма нужда от delete – паметта се освобождава автоматично.

Недостатъци:
- Ограничен размер
  - Стекът обикновено е малък (напр. 1MB - 8MB).
    - Windows ~1MB
    - Linux ~8MB
    - Може да се конфигурира (не се препоръчва).
  - Големи масиви или дълбока рекурсия тук водят до **Stack Overflow**.
- Stack Overflow проблем:
  - Възниква когато програмата се опита да използва повече стекова памет, отколкото е заделена.
  - Причини: много дълбока рекурсия, големи локални масиви, безкрайна рекурсия.
  - Резултат: програмата крашва със Segmentation Fault (Linux) или Access Violation (Windows).
  - Решение: използвайте динамична памет (Heap) за големи структури или оптимизирайте рекурсията.
- Кратък живот
  - Данните се губят веднага щом функцията приключи.
  - Не можете да върнете адрес към локална променлива (dangling pointer).

#### System / Kernel Space
Това е най-горната част на паметта, запазена за Операционната система (kernel code, drivers).  
Защита: Потребителският код (вашата програма) не може да чете или пише директно тук.  
Опит за достъп води до грешка (Segmentation Fault / Access Violation).  

# Динамична памет в C++ (Практическо приложение)

## Кратко Сравнение: Stack vs Heap

![Memory](images/Memory.png)

### Stack (Стекова памет)
- **Размер**: Предварително определен (~1-8MB, в зависимост от ОС).
- **Заделяне**: По време на компилация (compile-time) за известни размери.
- **Управление**: Автоматично - паметта се освобождава при излизане от scope (`}`).
- **Скорост**: Изключително бърза - една CPU инструкция.
- **Употреба**: Локални променливи, параметри на функции.

```c++
int value = 5;           // allocated on the Stack
int arr[100];            // allocated on the Stack (fixed size)
```

### Heap (Динамична памет)
- **Размер**: Ограничен от RAM и виртуалната памет (много по-голям от Stack).
- **Заделяне**: По време на изпълнение (runtime) - размерът може да е неизвестен предварително.
- **Управление**: Ръчно - програмистът задава (`new`) и освобождава (`delete`).
- **Скорост**: Бавна - изисква OS kernel извиквания.
- **Употреба**: Големи структури, масиви с динамичен размер.

```c++
int value = 5;           // allocated on the Stack
int* p = &value;         // pointer allocated on the Stack (сочи към Stack променлива)

int* hValue = new int;   // hValue (указателят) е на Stack
                         // но заделя 1 integer в Heap паметта
*hValue = 10;            // задава стойност на integer-а в Heap
```

**Визуална репрезентация**:
```
STACK                           HEAP
+----------------+              +----------------+
| value = 5      |              |  (allocated    |
| p = 0x...      |              |  by new int)   |
| hValue = 0x... | ---------->  +----------------+
+----------------+              |   10 (value)   |
                                +----------------+

```

## Оператор `new` (Heap Allocation)

Операторът `new` заделя динамична памет в Heap и връща указател към началото на заделената памет.

### Синтаксис
```c++
// Заделяне на един обект
int* ptr = new int;              // Заделя 1 integer в Heap
int* ptr2 = new int(42);         // Заделя и инициализира с 42

// Заделяне на масив
int n = 100;
int* arr = new int[n];           // n НЕ е задължително да е константа!
                                 // Размерът се определя по време на изпълнение (runtime)
```

### Как работи `new` (вътрешна механика)?
1. **Извикване на `malloc`**: `new` вътрешно извиква C функцията `malloc`.
2. **System Call**: `malloc` извиква системно извикване (`mmap`, `sbrk`) към OS kernel.
3. **Търсене на свободен блок**: OS търси свободен блок памет с достатъчен размер.
4. **Маркиране като зает**: OS маркира намерения блок като зает (set metadata bit to 1).
5. **Връщане на адрес**: `new` връща адреса на началото на блока.

### Важни характеристики на `new`
- Заделя памет с **динамичен размер** (размерът може да се определи по време на изпълнение).
- **Бавна операция** - изисква context switch към kernel space и търсене в heap.
- Динамичната памет **НЕ се освобождава автоматично** - нужен е `delete`.
- Ако няма достатъчно памет, `new` хвърля `std::bad_alloc` exception (или връща `nullptr` при `new(nothrow)`).

```c++
try { // Exceptions ще бъдат разгледани в курса по ООП, но се показва пример, в който може да няма достатъчно памет и ще се хвърли грешка.
    int* bigArray = new int[1000000000];  // Може да няма достатъчно памет
} catch (std::bad_alloc& e) {
    std::cerr << "Memory allocation failed: " << e.what() << std::endl;
}
```

## Оператор `delete` / `delete[]` (Heap Deallocation)

Операторът `delete` маркира динамично заделената памет като свободна, за да може да бъде преизползвана.

### Синтаксис
```c++
int* ptr = new int(42);
delete ptr;               // Освобождава паметта за един обект

int* arr = new int[100];
delete[] arr;             // Освобождава паметта за масив (забележете [] )
```

### Важни характеристики на `delete`
1. **НЕ изтрива реално данните!** - Това е критично да се разбере.
2. **Маркира блока като свободен**: Променя metadata флага от 1 на 0.
3. **Данните остават непроменени**: Стойностите в паметта остават докато не бъдат презаписани.

```c++
char* password = new char[20];
strcpy(password, "MySecretPass123!");  // Чувствителни данни в heap паметта

// Идеята (концептуално):
// Преди освобождаване е добре паметта да бъде презаписана

// ВАЖНО: обикновен memset МОЖЕ да бъде оптимизиран от компилатора и не е гаранция за сигурно изчистване!

delete[] password;
```

**Визуализация на проблема**:
```
Преди delete:               След delete:
HEAP                        HEAP
+------------------+        +------------------+
| password =       |        | password =       |
| "MySecretPass!"  |        | "MySecretPass!"  | <- ДАННИТЕ СА ТУК!
| [Metadata: 1]    |        | [Metadata: 0]    | <- Само флагът е променен
+------------------+        +------------------+
```

## Memory Leaks (Изтичане на памет)

Memory leak възниква когато заделена Heap памет не бъде освободена с `delete`.

### Пример за Memory Leak
```c++
void f()
{
  int x = 40;                  // allocated on the Stack
  char ch[2] = {'a', 'b'};     // allocated on the Stack
  int* ptr = new int[3];       // allocated on the Heap
  
  // ptr[0], ptr[1], ptr[2] са в Heap
  
} // <-- Функцията приключва
  // x и ch се изчистват автоматично (Stack)
  // ptr (указателят) се изчиства (Stack)
  // НО! Трите integer-а в Heap ОСТАВАТ ЗАДЕЛЕНИ
  // и няма начин да ги освободим (загубихме адреса)
```

![Memory-Leak-example](images/exampleMemoryLeak.png)

**Последствия**:
- Heap паметта остава маркирана като заета.
- При многократно извикване на функцията, Heap постепенно се изчерпва.
- Програмата може да крашне поради липса на памет (`std::bad_alloc`).

### Правилно управление на паметта
```c++
void f()
{
  int x = 40;
  char ch[2] = {'a', 'b'};
  int* ptr = new int[3];
  
  ptr[0] = 10;
  ptr[1] = 20;
  ptr[2] = 30;
  
  // Използваме паметта...
  
  delete[] ptr;  // Освобождаваме Heap паметта преди излизане от функцията
  ptr = nullptr; // Добра практика - предотвратява dangling pointer
}
```

## Добри практики
- Винаги съпоставяйте `new` с `delete`
```c++
int* p = new int;       // -> delete p;
int* arr = new int[10]; // -> delete[] arr;
```
- Занулявайте указатели след `delete`
```c++
delete ptr;
ptr = nullptr;  // Предотвратява double-delete и dangling pointer
```
- Презаписвайте чувствителни данни преди `delete`


## Задачи
1. Напишете програма, която въвежда от клавиатурата цяло число N и след това създава масив с размер N.
2. Напишете програма, която въвежда от клавиатурата цели числа N и M и след това създава матрица с размер NxM.
3. Напишете програма, която въвежда от клавиатурата цели числа N, M, Q и след това създава триизмерен масив с размер NxMxQ.
4. Напишете програма, която намира сумата на елементите над главния диагонал на квадратна матрица NxN, където N се въвежда от потребителя.
5. Напишете функция, която приема като параметър матрица NxM и връща транспонирата й матрица.
6. Напишете функция, която приема като параметър матрица NxM и матрица PxQ и връща тяхното матрично произведение. <br />
**Note**: NxM . PxQ = NxQ , тоест трябва m == p.
